<!doctype html>
<html lang="en">
<head>
  <title>!IR</title>
  <link rel='shortcut icon' href='favicon.png' type='image/png' />
  <link rel="manifest" href="manifest.webmanifest">
  <!--<link href="Style.css" rel="stylesheet" type="text/css"/>-->
  <style>

canvas {
    display: block; /* fix necessary to remove space at bottom of canvas */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

body {
  overscroll-behavior: contain;
}

#fade {
  display: none;
  position: fixed;
  top: 0%;
  left: 0%;
  width: 100%;
  height: 100%;
  background-color: black;
  z-index: 1001;
  -moz-opacity: 0.8;
  opacity: .80;
  filter: alpha(opacity=80);
}



#light {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  max-width: 600px;
  max-height: 360px;
  margin-left: -300px;
  margin-top: -180px;
  z-index: 1002;
  overflow: visible;
}

#boxclose {
  float: right;
  cursor: pointer;
  color: #fff;
  /*border: 1px solid #AEAEAE;*/
  border-radius: 3px;
  
  font-size: 31px;
  font-weight: bold;
  display: inline-block;
  line-height: 0px;
  padding: 11px 3px;
  position: absolute;
  right: 2px;
  top: 2px;
  z-index: 1002;
  opacity: 0.9;
}

.boxclose:before {
  content: "Ã—";
}

#fade:hover ~ #boxclose {
  display:none;
}
  
@font-face {
    font-family: "Syne";
    src: url("Syne-extra.otf");
}

#player{
  visibility:hidden;
}

.vimeo-wrapper {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
  
   pointer-events: none;
   overflow: hidden;
   z-index: 99 !important; 
}
.vimeo-wrapper iframe {
   width: 100vw;
   height: 56.25vw; /* Given a 16:9 aspect ratio, 9/16*100 = 56.25 */
   min-height: 100vh;
   min-width: 177.77vh; /* Given a 16:9 aspect ratio, 16/9*100 = 177.77 */
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
}


h1 { 
    color:white;
    position:absolute;
    visibility: hidden;
    top:50%;
    z-index:100; 
    width:100%; 
    text-align: center; 
    /*transform: translate(0,-100%); */
    font-family: 'Syne'; 
    font-weight: 100; 
    letter-spacing: 40px; 
    text-transform: uppercase;
    font-size: 28px; 
}

h3 { 
    color:white;

    z-index:100; 

    right: 0;
    bottom:0;
   /* transform: translate(0,-100%); */
    font-family: 'Syne'; 
    font-weight: 100; 
    text-transform: uppercase;
}

#info {
  position: absolute;
  padding-left: 50%;
  padding-bottom:2%;
  bottom:0;
}

#container {
  position: absolute;
  top: 0;
  left:0;
  width: 100%;
  height: 100%;
  visibility: hidden;
}

#theRest {
  color:white;
  font-family: 'Syne'; 
}
</style>
  <meta charset="utf-8">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body style="margin: 0;">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
  <script src="js/three/build/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/three/examples/js/loaders/GLTFLoader.js"></script>
  <script type="text/javascript" src="js/main.js"></script>

  <h1 id="example"></h1>

  <div id="container">
      <div id="info">
        <h3>Lorem ipsum dolor sit amet.</h3>
        <p id="theRest">Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet.</p>
    </div>
  </div>
  
  <div class="popup"><div class="text"></div></div>

  <video id="video" loop crossOrigin="anonymous" webkit-playsinline style="display:none">
			<!--<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>-->
			<source src="clean_vid.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
  </video>
  
  <div id="light" class='light'>
    <a class="boxclose" id="boxclose" onclick="lightbox_close();"></a>
    <!--<video id="VisaChipCardVideo" width="600" controls>
        <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4">
      </video>-->
      
  </div>
  <div id="fade" onClick="lightbox_close();"></div>

  <script>
    
    window.document.onkeydown = function(e) {
  if (!e) {
    e = event;
  }
  if (e.keyCode == 27) {
    lightbox_close();
  }
}
function lightbox_open() {
  //var lightBoxVideo = document.getElementById("VisaChipCardVideo");
  //lightBoxVideo.play();
  $('.light').append('<iframe width="560" height="315" src="https://www.youtube.com/embed/N2i-X9f01Ik?autoplay=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>');
  window.scrollTo(0, 0);
  document.getElementById('light').style.display = 'block';
  document.getElementById('fade').style.display = 'block';
}

function lightbox_close() {
  $('.light').empty();
  //var lightBoxVideo = document.getElementById("VisaChipCardVideo");
  document.getElementById('light').style.display = 'none';
  document.getElementById('fade').style.display = 'none';
  //lightBoxVideo.pause();
}

    
// Set up the scene, camera, and renderer as global variables.
var scene, camera, renderer;

var logo;
var tv;
var skate;
var plane;
var curCamPos;
var synth;
var phone;
var vr;
var vid;
var arch;

var mouseX;
var mouseY;


var video;

var controls;

var clickable = ["tv","flag","skate", "synth", "phone","vr", "vid", "arch"];

var firstPhase = true;

//var tween;

var numberOfVerticies;
var currentWaveHeight = 10;
var rowSize = 150;
var maxHeight = 20;
var t = 0.0;

init();
animate();

function vertexShader() {
return `
varying vec3 vUv; 
varying vec4 tvViewPosition; 
varying vec3 vecNormal;

void main() {
  vUv = position; 
  vec4 tvViewPosition = tvViewMatrix * vec4(position, 1.0);
  vecNormal = (tvViewMatrix * vec4(normal, 0.0)).xyz; //????????
  gl_Position = projectionMatrix * tvViewPosition; 
}
`
}
function fragmentShader() {
return `
  uniform vec3 colorA; 
  uniform vec3 colorB; 
  varying vec3 vUv;

  void main() {
    gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
  }
`
}

// Sets up the scene.
function init() {

  // Create the scene and set the scene size.
  scene = new THREE.Scene();

  const color = "black";
  const density = 0.1;
  const near = 8;
  const far = 20;
  scene.fog = new THREE.Fog(color, near, far);

  var WIDTH = window.innerWidth,
      HEIGHT = window.innerHeight;
      window.scrollTo(0,1);


  var ori = (WIDTH > HEIGHT) ? false : true;
  console.log("ori ", ori.toString());

  // Create a renderer and add it to the DOM.
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(WIDTH, HEIGHT);  


  document.body.appendChild(renderer.domElement);

  // Create a camera, zoom it out from the tv a bit, and add it to the scene.
  camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.001, 20000);
  //camera.position.set(-3,6,0);
  //camera.position.set(-3,0,0);
  camera.position.set(-400,0,0);
  animateMove(camera.position,{x:-23,y:0,z:0});
  scene.add(camera);

  var example = document.getElementById('example');
  example.textContent="Virtual";

  var container = document.getElementById('container');

  
  video = document.getElementById( 'video' );
	videoTexture = new THREE.VideoTexture( video );

  // Create an event listener that resizes the renderer with the browser window.
  window.addEventListener('resize', function() {
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;
    renderer.setSize(WIDTH, HEIGHT);
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();
  });

  window.addEventListener("deviceorientation", function(event) {
    event.stopPropagation();
    event = event || window.event;

    var rotatedY =  Math.min(Math.max(parseInt(Math.floor(event.gamma)), -45), 45),
    rotatedX = Math.min(Math.max(parseInt(Math.floor(event.beta)), -45), 45),
    boxWidth = WIDTH,
    boxHeight = HEIGHT;

    var moveX = ((boxWidth/2) * rotatedY) / 45;
    var moveY = ((boxWidth/2) * rotatedX) / 45;
    console.log("moveX ",moveX);
    console.log("moveY ",moveY);
    camera.position.z =  curCamPos.z - moveX * 0.5;
    camera.position.y = curCamPos.y + moveY* 0.5;
  });

  document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchmove', handleTouchMove, false);

  var xDown = null;                                                        
var yDown = null;

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches; // jQuery
}                                                     

function handleTouchStart(evt) {
    const firstTouch = getTouches(evt)[0];                                      
    xDown = firstTouch.clientX;                                      
    yDown = firstTouch.clientY;                                      
};                                                

function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;

    if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
        if ( xDiff > 0 ) {
            /* left swipe */ 
        } else {
            /* right swipe */
        }                       
    } else {
        if ( yDiff > 0 ) {
            /* up swipe */ 
            scroll(1);
        } else { 
            /* down swipe */
            scroll(-1);
        }                                                                 
    }
    /* reset values */
    xDown = null;
    yDown = null;                                             
};


  // initialize object to perform world/screen calculations
var raycaster = new THREE.Raycaster(); 
var mouse = new THREE.Vector2(), INTERSECTED;
document.addEventListener( 'mousedown', onDocumentMouseDown, false );
document.addEventListener( 'mousemove', onDocumentMouseMove, false );

function onDocumentMouseDown( event ) {
  if(firstPhase == true){
    initTrans();
    return;
  }

mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	
raycaster.setFromCamera( mouse, camera );
var intersects = raycaster.intersectObjects(scene.children,true);
var to;
var namee = intersects[0].object.name;
if ( intersects.length > 0 && clickable.includes(intersects[0].object.name))
{
if(namee == "tv" ){
    to = tv;
    container.style.visibility = 'visible';
}
if(namee == "flag"){
  to = plane;
  container.style.visibility = 'visible';
}
if(namee == "skate"){
  to = skate;
}
if(namee == "synth"){ 
  to = synth;
}
if(namee == "phone"){
  to = phone;
}
if(namee == "vr"){
  to = vr;
}
if(namee == "vid"){
  to = vid;
}
if(namee == "arch"){
  to = arch;
}

switch(namee) {
  case "instance_3":
  window.open('http://www.zenbauhaus.wordpress.com/', '_blank');  
  case "Cone":
  window.open('http://www.notreal.xyz/', '_blank');   
    break;
  case "Plane":
  window.open('https://www.instagram.com/notreal_virtual/', '_blank'); 
    break;
  case "Plane001":
  window.open('https://www.facebook.com/notrealvirtual/', '_blank'); 
    break;
  default:
    // code block
}
//clicker(intersects[ 0 ].object);
//lightbox_open();
animateMove(camera.position,{x: to.position.x - 2, y: to.position.y,z: to.position.z + 0.5},to.position,1000);

/*
$('.text').empty();
$('.popup').append("<div class='text'><p>"+ intersects[0].object.name +"</p></div>");
$('.popup').show();
*/

}
}

function lerp (start, end, amt){
  return (1-amt)*start+amt*end
}

function onDocumentMouseMove( event ) {

    mouseX = (event.clientX - window.innerWidth / 2) ;
    mouseY = (event.clientY - window.innerHeight / 2);
    if(mouseX != 0){
      mouseX = mouseX  / (window.innerWidth / 2);
    }
    if(mouseY != 0){
      mouseY = mouseY  / (window.innerHeight / 2);
    }

    /*
    camera.position.x += ( mouseX - camera.position.x ) * 0.05;
        camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
        */
    //console.log( mouseX, mouseY);
    camera.position.z =  curCamPos.z - mouseX * 0.5;
    camera.position.y = curCamPos.y + mouseY* 0.5;
    //set up camera position
    //camera.lookAt(scene.position);

mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	

raycaster.setFromCamera( mouse, camera );
var intersects = raycaster.intersectObjects( scene.children, true );
var canvas = document.body.getElementsByTagName('canvas')[0];
console.log(intersects[0].object.name);
if (intersects.length > 0 && clickable.includes(intersects[0].object.name)) {

if(intersects[0].object.name == "tv"){
    tv.rotation.x += 0.005;
    tv.scale.set(0.01,0.01,0.01);

}
        if(intersects[0].object.name == "skate" ){
          skate.rotation.x += 0.005;
          skate.scale.set(0.55,0.55,0.55);

        }
        if(intersects[0].object.name == "flag"){
          plane.rotation.x += 0.005;
          plane.scale.set(0.008,0.008,0.008);
      
        }
        if(intersects[0].object.name == "synth"){
    //tv.rotation.x += 0.005;
    tv.scale.set(0.01,0.01,0.01);
}
canvas.style.cursor = "pointer";
} else {
  //tv.scale.set(0.008,0.008,0.008);
  skate.scale.set(0.5,0.5,0.5);
  plane.scale.set(0.006,0.006,0.006);
  canvas.style.cursor = "default";
}
}
function clicker(obj){
console.group('intersection');
  console.log(obj.point);
  console.log(obj.rotation)
console.groupEnd();
//window.open('http://www.pericror.com/', '_blank');  
if(obj.active === true){
//obj.material.color.setRGB(0,1,0);
obj.active = false;
}
else{
//obj.material.color.setRGB(1,0,0);
obj.active = true;
}
//obj.geometry.colorsNeedUpdate = true;
}

function animateScale(vectorToAnimate, target, options){
console.log("animating");
var speed = 200;
// create the tween
var tween = new TWEEN.Tween(vectorToAnimate).to(target, 2000)
    .easing(TWEEN.Easing.Elastic.InOut)
    .onComplete(function(){
      setTimeout(function() {
        
      }, 4000);
    });
    tween.onUpdate(function(){
      logo.scale.x = vectorToAnimate.x;
      logo.scale.y = vectorToAnimate.y;
        logo.scale.z = vectorToAnimate.z;
    });
    // start the tween
    tween.start();
}

function animateMove(vectorToAnimate, target, lookAt, speed){
console.log("tween animating");
curCamPos= target;
// create the tween
var spee = speed ? speed : 4000;
var tween = new TWEEN.Tween(vectorToAnimate).to(target, spee)
    .easing(TWEEN.Easing.Quadratic.Out)
    .onComplete(function(){
      console.log('tween done');
      curCamPos= target;
    });
    tween.onUpdate(function(){
      camera.position.x = vectorToAnimate.x;
      camera.position.y = vectorToAnimate.y/* + mouseY * 0.5 */;
      camera.position.z = vectorToAnimate.z  /*- mouseX * 0.5 */;
    if(lookAt){
        controls.target.set(vectorToAnimate.x + 2,vectorToAnimate.y, vectorToAnimate.z);
        //camera.lookAt({x:vectorToAnimate.x + 2,y: vectorToAnimate.y,z:vectorToAnimate.z});
      }
    });
    /*
    if(lookAt){
  var vec = camera.lookAt;
  var tween2 = new TWEEN.Tween(vec).to(lookAt, 4000)
    .easing(TWEEN.Easing.Quadratic.InOut)
    .onComplete(function(){
      console.log('done');
    });
    tween2.onUpdate(function(){
      //console.log(camera.lookAt,vec);
      //camera.lookAt(vec);
      controls.target = vec;
    });
    tween2.start(); 
  }*/
   // start the tween
tween.start();
}

function initTrans(){
  video.play();
  var speed = 200;
  animateMove(camera.position, {x:-3, y: 0, z: 0}, {x:0, y: 0, z: 0}, 500);
  firstPhase = false;
  logo.visible = false;
        //example.style.visibility = 'visible';
        setTimeout(function() {
          example.style.visibility = 'visible';
          example.innerHTML="Augmented";
          setTimeout(function() {
            example.innerHTML="Motion";
            setTimeout(function() {
              example.innerHTML="AI";
              setTimeout(function() {
                example.innerHTML="PR";
                setTimeout(function() {
                  example.innerHTML="Creative";
                  setTimeout(function() {
                    example.innerHTML="something";
                    setTimeout(function() {
                      example.innerHTML="";
                        plane.visible = true;
                        tv.visible = true;
                        skate.visible = true;
                    }, speed);
                  }, speed);
                }, speed);
              }, speed);
            }, speed);
          }, speed);
        }, 200);
}

function scroll(e){
  if(firstPhase == true){
    initTrans();
    return;
  }

console.log("scroll " + e);
if(e < 0 && camera.position.z > -1.1 && camera.position.z < 1.1 && camera.position.x < 0 && camera.position.x > -10){
  console.log("move 1");
  animateMove(camera.position,{x: 12 , y: 0,z: 0},{x:11,y:0,z:0},1000);
}
else if(e > 0 && camera.position.x > 10){
  console.log("move 2");
  animateMove(camera.position,{x: -3, y: 0, z: 0},{x:0,y:0,z:0},1000);
}
else if(e < 0 && camera.position.x < 10 && curCamPos.y != 0 && curCamPos.z != 0 ){
  console.log("move 3");
  animateMove(camera.position,{x: -3, y: 0, z: 0},{x:0,y:0,z:0},1000);
  container.style.visibility='hidden';
}
}

window.addEventListener("wheel", function(e) {
var e = window.event || e; // old IE support
var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
scroll(delta);

//console.log("scrolled "+ delta.toString());
//camera.position.y += event.wheelDeltaY * 0.1;;
}, true);
    
//Space background is a large sphere
var spacetex = new THREE.TextureLoader().load("https://s3-us-west-2.amazonaws.com/s.cdpn.io/96252/space.jpg");
var spacesphereGeo = new THREE.SphereGeometry(15,15,15);
var spacesphereMat = new THREE.MeshPhongMaterial();
spacesphereMat.map = spacetex;

var spacesphere = new THREE.Mesh(spacesphereGeo,spacesphereMat);

//spacesphere needs to be double sided as the camera is within the spacesphere
spacesphere.material.side = THREE.DoubleSide;

spacesphere.material.map.wrapS = THREE.RepeatWrapping; 
spacesphere.material.map.wrapT = THREE.RepeatWrapping;
spacesphere.material.map.repeat.set( 5, 3);

//scene.add(spacesphere);


    let uniforms = {
    colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
    colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}
}
    let material =  new THREE.ShaderMaterial({
      uniforms: uniforms,
      fragmentShader: fragmentShader(),
      vertexShader: vertexShader(),
});


    var envMap = new THREE.TextureLoader().load('models/envMap.jpg');
    let vlajkaMat =  new THREE.MeshLambertMaterial({ map : envMap});
    plane = new THREE.Mesh(new THREE.PlaneGeometry(150, 200, rowSize, rowSize), vlajkaMat);
    plane.scale.set(0.006,0.006,0.006);
    plane.rotation.y = getRadian(-90);
    plane.rotation.z = getRadian(90);
    if(ori){
      plane.position.set(7,2.2,-1.3);
    }else{
      plane.position.set(5,2,-3);
    }
    
    plane.name = "flag";
    plane.visible = false;
    numberOfVerticies = plane.geometry.vertices.length;
    initPlane();
    scene.add(plane);


    function initPlane() {
    
    for(var j = 0; j < rowSize+1; j++) {
        for(var i = 0; i < rowSize+1; i++) {
            //plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight-j%maxHeight;
            plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight*Math.sin(j/rowSize*3);
        }
    }
    
    }
    function getRadian(x) {
    return (Math.PI*x)/180;
}

  // Set the background color of the scene.
  //renderer.setClearColorHex(0x333F47, 1);

  // Create a light, set its position, and add it to the scene.
  var light = new THREE.PointLight(0xffffff);
  light.position.set(-100,200,100);
  scene.add(light);

  var light2 = new THREE.PointLight(0xffffff);
  light2.position.set(4.6,1.8,2);
  scene.add(light2);

  let ambientLight = new THREE.AmbientLight(0x505050);
  scene.add(ambientLight);

  var cubeloader = new THREE.CubeTextureLoader();
cubeloader.setPath( 'lightblue/' );

var textureCube = cubeloader.load( [
	'back.png', 'front.png',
	'top.png', 'left.png',
	'bot.png', 'right.png'
] );

  var materiall = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.4,flatShading:true,/* envMap: textureCube,*/metalness: 1});
  var igAlpha = new THREE.TextureLoader().load("models/igAlphaa.png");
  var igMat = new THREE.MeshPhongMaterial({color: 0xffffff, alphaMap: igAlpha,transparent: true, opacity: 0.8, side: THREE.DoubleSide});
  var fbAlpha = new THREE.TextureLoader().load("models/fbAlpha.png");
  var fbMat = new THREE.MeshPhongMaterial({color: 0xffffff, alphaMap: fbAlpha,transparent: true, opacity: 0.8, side: THREE.DoubleSide});

  var geometry = new THREE.BoxGeometry(1, 1, 1 );
  var cube = new THREE.Mesh( geometry, materiall);
  cube.position.set(-20,0,0);
  //scene.add( cube );

  var usloader = new THREE.GLTFLoader();
  usloader.load( "models/ussse.glb", function(gltf){
    us = gltf.scene;  
    if(ori)us.rotation.x = 92;
    //us.rotation.z = 30.4;
    //us.rotation.y = -95;
    if(ori){
      us.scale.set(0.3,0.3,0.3);
    }
    else
    {
      us.scale.set(0.7,0.7,0.7);
    }
    us.position.set(18,ori ? -0.2 : -0.8,0);
    //us.name="use";
    us.visible = true;
    //us.callback = function() { console.log("Hello world!");};
    us.traverse(function (o) {
      if (o.isMesh) {
        clickable.push(o.name.toString());
        if(o.name == "Plane") o.material = igMat;
        if(o.name == "Plane001") o.material = fbMat;
        
      }
    });
    scene.add(us);
  });

  // Load in the mesh and add it to the scene.
  var loader = new THREE.GLTFLoader();
  loader.load( "models/TV.glb", function(gltf){
    var videoMat = new THREE.MeshLambertMaterial({ map : videoTexture});
    //mesh = new THREE.Mesh(geometry, material);
    tv = gltf.scene;
    //tv.rotation.x = -90;
    tv.rotation.z = 30.4;
    tv.rotation.y = 155.4;
    tv.scale.set(0.01,0.01,0.01);
    if(ori == true){
      tv.position.set(6,1.9,1);
    }
    else {
      tv.position.set(4,1.2,2.5);
    }
    tv.name="tv";
    tv.visible = false;
    tv.callback = function() { console.log("Hello world!");};
    tv.traverse(function (o) {
      if (o.isMesh) {
        if(o.name == "Retro_TV_2") o.material= videoMat;
        o.name = "tv";
      }
    });
    scene.add(tv);
  });

  var archloader = new THREE.GLTFLoader();
  archloader.load( "models/Apartment.gltf", function(gltf){
    //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
    //mesh = new THREE.Mesh(geometry, material);
    arch = gltf.scene;
    arch.rotation.x = 90;
    arch.rotation.z = 30.4;
    arch.rotation.y = 155.4;
    arch.scale.set(0.05,0.05,0.05);
    if(ori){
      arch.position.set(4,-0.4,0.6);  
    }
    else { 
      arch.position.set(2,-0.6,2.5);  
    }
    arch.name="arch";
    arch.visible = true;
    arch.callback = function() { console.log("Hello world!");};
    arch.traverse(function (o) {
      if (o.isMesh) {
        o.name = "arch";
      }
    });
    scene.add(arch);
  });

  var synthloader = new THREE.GLTFLoader();
  synthloader.load( "models/synth.glb", function(gltf){
    //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
    //mesh = new THREE.Mesh(geometry, material);
    synth = gltf.scene;
    synth.rotation.x = 90;
    synth.rotation.z = 30.4;
    synth.rotation.y = 158.4;
    synth.scale.set(0.32,0.32,0.32);
    if(ori){
      synth.position.set(5,2.2,0);
    }else{
      synth.position.set(2,1,0);
    }
    synth.position.set(2,1,0);
    synth.name="synth";
    synth.visible = true;
    //synth.callback = function() { console.log("Hello world!");};
    synth.traverse(function (o) {
      if (o.isMesh) {
        o.name = "synth";
      }
    });
    scene.add(synth);
  });

  var vidloader = new THREE.GLTFLoader();
  vidloader.load( "models/video.glb", function(gltf){
      vid = gltf.scene;
    //vid.rotation.x = 90;
    vid.rotation.z = 35.4;
    vid.rotation.y = -158.4;
    vid.scale.set(0.4,0.4,0.4);
    if(ori){
      vid.position.set(4,0.2,-0.8);
    }
    else{
      vid.position.set(2,0.2,-2.5);
    }
    vid.name="vide";
    vid.visible = true;
    //synth.callback = function() { console.log("Hello world!");};
    vid.traverse(function (o) {
      if (o.isMesh) {
        o.name = "vid";
      }
    });
    scene.add(vid);
  });

  var vrloader = new THREE.GLTFLoader();
  vrloader.load( "models/vr.glb", function(gltf){
      vr = gltf.scene;
    //vr.rotation.x = 90;
    vr.rotation.z = 30.4;
    vr.rotation.y = 158.4;
    vr.scale.set(0.7,0.7,0.7);
    if(ori){
      vr.position.set(5,-0.8,1);
    }else{
      vr.position.set(1,-0.6,-1.5);
    }
    
    vr.name="vr";
    vr.visible = true;
    //synth.callback = function() { console.log("Hello world!");};
    vr.traverse(function (o) {
      if (o.isMesh) {
        o.name = "vr";
      }
    });
    scene.add(vr);
  });

  var camloader = new THREE.GLTFLoader();
  camloader.load( "models/what2.glb", function(gltf){
    //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
    //mesh = new THREE.Mesh(geometry, material);
    cam = gltf.scene;
    cam.rotation.x = 90;
    cam.rotation.z = 30.4;
    cam.rotation.y = 158.4;
    cam.scale.set(0.0003,0.0003,0.0003);
    //cam.position.set(-1,0,2.5);
    cam.name="not";
    cam.visible = true;
    //synth.callback = function() { console.log("Hello world!");};
    cam.traverse(function (o) {
      if (o.isMesh) {
        o.name = "not";
      }
    });
    scene.add(cam);
  });

  var phoneloader = new THREE.GLTFLoader();
  phoneloader.load( "models/pphonee.glb", function(gltf){
    //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
    //mesh = new THREE.Mesh(geometry, material);
    phone = gltf.scene;
    phone.rotation.x = 90;
    phone.rotation.z = 30.4;
    phone.rotation.y = 155.4;
    phone.scale.set(0.06,0.06,0.06);
    phone.position.set(0,-0.5,0.3);
    phone.name="phone";
    phone.visible = true;
    //synth.callback = function() { console.log("Hello world!");};
    var videoMatt = new THREE.MeshLambertMaterial({ map : videoTexture});
    phone.traverse(function (o) {
      if (o.isMesh) {
        if(o.name == "Phone_01_Cube.037_0"){
          o.material = videoMatt;
        }
        else o.material = materiall
        o.name = "phone";
        
      }
    });
    scene.add(phone);
  });
  
  // Load in the mesh and add it to the scene.
  var loaderSkate = new THREE.GLTFLoader();
  loaderSkate.load( "models/what.glb", function(gltf){
    //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
    //mesh = new THREE.Mesh(geometry, material);
    skate = gltf.scene;
    skate.rotation.x = 180;
    skate.rotation.z = 45;
    skate.rotation.y = 90;
    skate.scale.set(0.5,0.5,0.5);
    skate.position.set(5,1.2,-2.5);
    skate.visible = false;
    skate.name = "skate";
    //skate.callback = function() { console.log("Hello world!");};
    skate.traverse(function (o) {
      if (o.isMesh) {
        o.name = "skate";
      }
    });
    scene.add(skate);
  });

  var loaderLogo = new THREE.GLTFLoader();
  loaderLogo.load( "models/notReal.glb", function(gltf){
    logo = gltf.scene;
    //logo.rotation.x += 90;
    //logo.rotation.z = 90;
    logo.rotation.y = 90;
    //logo.scale.set(-0.8,0.8,0.8);
    logo.scale.set(0,0.8,0.8);
    if(ori == true){
      logo.position.set(-16,0,-0.9);
    }else{
      logo.position.set(-19,0,-0.8);
    }
    logo.traverse(function (o) {
if (o.isMesh) {
 o.material = materiall;
}
});
    scene.add(logo);
    animateScale({x:0.8,y:0.8,z:0},{x:-0.8,y:0.8,z:0.8} );
  });

  

  var geoGround = new THREE.PlaneBufferGeometry( 100,100 );
  var ground = new THREE.Mesh( geoGround, new THREE.MeshPhongMaterial({color:"white",wireframe:true, }));
  ground.rotation.z = Math.PI/180 * -45;
  ground.rotation.x = Math.PI/180 * -90;
  ground.position.y=-0.5;
  //scene.add(ground);

  // Add OrbitControls so that we can pan around with the mouse.
 controls = new THREE.OrbitControls(camera, renderer.domElement);

}
// Renders the scene and updates the render as needed.
function animate() {

  // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
  requestAnimationFrame(animate);
  if(tv) tv.rotation.z += 0.001;
  if(tv) tv.rotation.y += 0.0001;
  if(tv) tv.position.y = -0.2*Math.sin(t*0.01) + 1.5;

  if(us) us.traverse(function (o) {
      if (o.isMesh) {
        o.rotation.y += 0.0002;
        o.rotation.z += 0.002;
      }
    });

  if(skate){ skate.rotation.z += 0.001;
  skate.rotation.y += 0.0001;
   skate.position.z = -4*Math.sin(t*0.001);
   skate.position.y = -3*Math.sin(t*0.0005) - 1.5;
  }
  if(vr){ vr.rotation.z += 0.001;
    vr.rotation.y += 0.0001;
     vr.position.z = -0.3*Math.sin(t*0.001) - 1.5;
     vr.position.y = -0.4*Math.sin(t*0.0005) - 0.6;
    }
    if(synth){ synth.rotation.z += 0.001;
    synth.rotation.y += 0.0001;
    synth.position.z = -0.4*Math.sin(t*0.001) ;
     synth.position.y = -0.2*Math.sin(t*0.0005) + 1;
    }

    if(phone){ phone.rotation.z += 0.001;
    phone.rotation.y += 0.0001;
     phone.position.z = -0.2*Math.sin(t*0.001) + 0.3;
     phone.position.y = -0.3*Math.sin(t*0.0005) - 0.5;
    }

    if(vid){ vid.rotation.z += 0.001;
    vid.rotation.y += 0.0001;
    }

    if(arch){ arch.rotation.z += 0.001;
    arch.rotation.y += 0.0001;
    }

  if(plane){
    plane.rotation.z += 0.001;
  }


  for(var j = 0; j < rowSize+1; j++) {
        for(var i = 0; i < rowSize+1; i++) {
            plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight*Math.sin(j/rowSize*3 + t*.05);
            plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/5*Math.sin(j/rowSize*12 + t*0.04);
            plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/13*Math.cos(j/rowSize*18 + t*0.2);
            
            plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight*Math.cos(i/rowSize*3 + t*.05);
            plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/5*Math.cos(i/rowSize*12 + t*0.04);
            plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/13*Math.sin(i/rowSize*18 + t*0.2);
        }
    }
    t+=0.55;
    
    plane.geometry.verticesNeedUpdate = true;



    TWEEN.update();
  // Render the scene.
  renderer.render(scene, camera);
  controls.update();

}
  </script>
</body>
</html>
