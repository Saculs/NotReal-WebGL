<!doctype html>
<html lang="en">
<head>
  <title>!IR</title>
  <link rel='shortcut icon' href='favicon.png' type='image/png' />
  <meta charset="utf-8">
</head>
<body style="margin: 0;">

  <script src="js/three/build/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/three/examples/js/loaders/GLTFLoader.js"></script>
  <script src="main.js"></script>
  
  <script>

    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer;

    var model;
    var skate;
    var cubee;

    var plane, numberOfVerticies;
    var currentWaveHeight = 10;
    var rowSize = 150;
    var maxHeight = 20;
    var t = 0.0;

    init();
    animate();

    function vertexShader() {
  return `
    varying vec3 vUv; 
    varying vec4 modelViewPosition; 
    varying vec3 vecNormal;

    void main() {
      vUv = position; 
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz; //????????
      gl_Position = projectionMatrix * modelViewPosition; 
    }
  `
}
function fragmentShader() {
  return `
      uniform vec3 colorA; 
      uniform vec3 colorB; 
      varying vec3 vUv;

      void main() {
        gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
      }
  `
}
    // Sets up the scene.
    function init() {

      // Create the scene and set the scene size.
      scene = new THREE.Scene();

      const color = "black";
      const density = 0.1;
      const near = 8;
      const far = 20;
      scene.fog = new THREE.Fog(color, near, far);

      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      // Create a renderer and add it to the DOM.
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(WIDTH, HEIGHT);


      document.body.appendChild(renderer.domElement);

      // Create a camera, zoom it out from the model a bit, and add it to the scene.
      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
      //camera.position.set(-3,6,0);
      camera.position.set(-3,0,0);
      scene.add(camera);


      // Create an event listener that resizes the renderer with the browser window.
      window.addEventListener('resize', function() {
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
      });


      // initialize object to perform world/screen calculations
      var raycaster = new THREE.Raycaster(); 
      var mouse = new THREE.Vector2(), INTERSECTED;

//////////////////////////////////////////
    //    Mousedown find the Obj
//////////////////////////////////////////
	// when the mouse moves, call the given function
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
   document.addEventListener( 'mousemove', onDocumentMouseMove, false );

   //All Clickable Objects
   var targetList = [model,cubee, skate];

function onDocumentMouseDown( event ) {
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	
	raycaster.setFromCamera( mouse, camera );
	var intersects = raycaster.intersectObjects(scene.children);
	
	if ( intersects.length > 0 )
	{
    clicker(intersects[ 0 ].object);
	}
}

function onDocumentMouseMove( event ) {
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	
  
  raycaster.setFromCamera( mouse, camera );
  var intersects = raycaster.intersectObjects( scene.children, true );
  var canvas = document.body.getElementsByTagName('canvas')[0];
  if (intersects.length > 0) {
    console.log(intersects[0])
            if(intersects[0].object.name == "name" || intersects[0].object.name == "tv" ){
            model.rotation.x += 0.005;
            model.scale.set(0.0022,0.0022,0.0022);
            canvas.style.cursor = "pointer";
            }
            if(intersects[0].object.name == "flag"){
            plane.rotation.x += 0.005;
            plane.scale.set(0.022,0.022,0.022);
            canvas.style.cursor = "pointer";
            }
        } else {
          model.scale.set(0.002,0.002,0.002);
          plane.scale.set(0.02,0.02,0.02);
            canvas.style.cursor = "default";
        }
}
function clicker(obj){
  console.log(obj);
    console.group('intersection');
	     console.log(obj.point);
  console.log(obj.rotation)
    console.groupEnd();
  
        //window.open('http://www.pericror.com/', '_blank');

  
  if(obj.active === true){
    obj.material.color.setRGB(0,1,0);
    obj.active = false;
  }
  else{
    obj.material.color.setRGB(1,0,0);
    obj.active = true;
  }
	obj.geometry.colorsNeedUpdate = true;
}
        
        let uniforms = {
        colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
        colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}
    }
        let material =  new THREE.ShaderMaterial({
    uniforms: uniforms,
    fragmentShader: fragmentShader(),
    vertexShader: vertexShader(),
  });


        var envMap = new THREE.TextureLoader().load('models/envMap.jpg');
        let vlajkaMat =  new THREE.MeshLambertMaterial({ map : envMap});
        plane = new THREE.Mesh(new THREE.PlaneGeometry(150, 200, rowSize, rowSize), vlajkaMat);
        plane.scale.set(0.02,0.02,0.02);
        plane.rotation.y = getRadian(-90);
        plane.rotation.z = getRadian(90);
        plane.position.set(10,3,-3);
        plane.name = "flag";
        numberOfVerticies = plane.geometry.vertices.length;
        initPlane();
        scene.add(plane);

        function initPlane() {
        
        for(var j = 0; j < rowSize+1; j++) {
            for(var i = 0; i < rowSize+1; i++) {
                //plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight-j%maxHeight;
                plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight*Math.sin(j/rowSize*3);
            }
        }
        
        }
        function getRadian(x) {
        return (Math.PI*x)/180;
    }

      // Set the background color of the scene.
      //renderer.setClearColorHex(0x333F47, 1);

      // Create a light, set its position, and add it to the scene.
      var light = new THREE.PointLight(0xffffff);
      light.position.set(-100,200,100);
      scene.add(light);

      var light2 = new THREE.PointLight(0xffffff);
      light2.position.set(4.6,1.8,2);
      scene.add(light2);

      var geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
      var mater = new THREE.MeshBasicMaterial( {color: 0xffffff} );
      var cube = new THREE.Mesh( geometry, mater);
      scene.add( cube );

      let ambientLight = new THREE.AmbientLight(0x505050);
      scene.add(ambientLight);

      var materiall = new THREE.MeshPhongMaterial({color: 0xffffff, roughness: 0,flatShading:true});


      // Load in the mesh and add it to the scene.
      var loader = new THREE.GLTFLoader();
      loader.load( "models/TV.glb", function(gltf){
        //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
        //mesh = new THREE.Mesh(geometry, material);
        model = gltf.scene;
        model.rotation.x = 90;
        model.rotation.z = 30.4;
        model.rotation.y = 155.4;
        model.scale.set(0.002,0.002,0.002);
        model.position.set(5,1.2,2.5);
        model.name="tv";
        model.callback = function() { console.log("Hello world!");};
        scene.add(model);
      });
      
      // Load in the mesh and add it to the scene.
      var loaderSkate = new THREE.GLTFLoader();
      loader.load( "models/skate.glb", function(gltf){
        //var material = new THREE.MeshLambertMaterial({color: 0x55B663});
        //mesh = new THREE.Mesh(geometry, material);
        skate = gltf.scene;
        skate.rotation.x = 180;
        skate.rotation.z = 45;
        skate.rotation.y = 90;
        skate.scale.set(0.5,0.5,0.5);
        skate.position.set(5,1.2,-2.5);
        //skate.callback = function() { console.log("Hello world!");};
        scene.add(skate);
      });

      var loaderLogo = new THREE.GLTFLoader();
      loaderLogo.load( "models/notReal.glb", function(gltf){
        modell = gltf.scene;
        //modell.rotation.x += 90;
        //modell.rotation.z = 90;
        modell.rotation.y = 90;
        modell.scale.set(-0.8,0.8,0.8);
        modell.position.set(1,0,-0.8);
        modell.traverse(function (o) {
    if (o.isMesh) {
     o.material = materiall;
    }
  });
        //modell.material.set(material);
        scene.add(modell);
      });

      var geometr = new THREE.BoxGeometry( 1, 1, 1 );
      var cubee = new THREE.Mesh( geometr, mater);
      cubee.position.set(5,1.2,2.5);
      cubee.callback = function() { console.log("Hello world!");};
      cubee.name = "name";
      scene.add(cubee);

      var geoGround = new THREE.PlaneBufferGeometry( 100,100 );
      var ground = new THREE.Mesh( geoGround, new THREE.MeshPhongMaterial({color:"white",wireframe:true, }));
      ground.rotation.z = Math.PI/180 * -45;
      ground.rotation.x = Math.PI/180 * -90;
      ground.position.y=-0.5;
      //scene.add(ground);

      // Add OrbitControls so that we can pan around with the mouse.
      controls = new THREE.OrbitControls(camera, renderer.domElement);

    }
    // Renders the scene and updates the render as needed.
    function animate() {

      // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      requestAnimationFrame(animate);
      if(model) model.rotation.z += 0.001;
      if(model) model.rotation.y += 0.0001;
      if(model) model.position.y = -0.2*Math.sin(t*0.01) + 1.5;


      if(skate){ skate.rotation.z += 0.001;
      skate.rotation.y += 0.0001;
       skate.position.z = -7*Math.sin(t*0.001);
       skate.position.y = -3*Math.sin(t*0.0005) - 1.5;
      }


      for(var j = 0; j < rowSize+1; j++) {
            for(var i = 0; i < rowSize+1; i++) {
                plane.geometry.vertices[(rowSize+1)*j + i].z = maxHeight*Math.sin(j/rowSize*3 + t*.05);
                plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/5*Math.sin(j/rowSize*12 + t*0.04);
                plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/13*Math.cos(j/rowSize*18 + t*0.2);
                
                plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight*Math.cos(i/rowSize*3 + t*.05);
                plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/5*Math.cos(i/rowSize*12 + t*0.04);
                plane.geometry.vertices[(rowSize+1)*j + i].z += maxHeight/13*Math.sin(i/rowSize*18 + t*0.2);
            }
        }
        t+=0.55;
        
        plane.geometry.verticesNeedUpdate = true;




      // Render the scene.
      renderer.render(scene, camera);
      controls.update();

    }

  </script>

</body>
</html>
